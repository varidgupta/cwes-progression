<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Officer Promotion Simulator — with Monthly Analytics</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 0; }
    .container { max-width: 1100px; margin: 20px auto; background: #fff; padding: 20px; border-radius: 8px; }
    h1 { text-align: center; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background: #eee; position: sticky; top: 0; }
    input[type="number"], input[type="date"], select { width: 100%; padding: 5px; box-sizing: border-box; }
    button { padding: 10px 20px; background: #007BFF; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #0056b3; }
    .scroll-pane { max-height: 300px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #ccc; }
    pre { background: #f0f0f0; padding: 10px; border-radius: 4px; }
    .controls-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .controls-row label { font-weight: 600; }

    /* New: analytics layout */
    .analytics { display: grid; grid-template-columns: 1.3fr 1fr; gap: 16px; align-items: start; }
    .card { background: #fff; border: 1px solid #e4e4e4; border-radius: 8px; padding: 12px; }
    .card h3 { margin: 0 0 8px 0; }
    .eligible-list { max-height: 360px; overflow: auto; border: 1px dashed #ddd; padding: 8px; border-radius: 6px; }
    .month-row { margin-bottom: 10px; }
    .month-row .tag { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #eef; font-size: 12px; margin-left: 6px; }

    @media (max-width: 980px) {
      .analytics { grid-template-columns: 1fr; }
    }

    /* fixed, consistent size; prevents resize feedback */
    /* Let CSS define a stable, responsive box for the chart */
    .card #monthlyChart {
      width: 100%;
      max-width: 100%;
      aspect-ratio: 2 / 1;    /* tweak to taste (e.g., 16/9, 3/2) */
      height: auto !important;/* canvas height derives from aspect ratio */
      display: block;
    }


  </style>
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
<div class="container">
  <h1>Officer Promotion Simulator</h1>

  <h2>Officers List</h2>
  <div class="scroll-pane">
    <table id="officerListTable">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
  <div style="text-align:center; margin-bottom:20px;">
    <button id="refreshBtn">Refresh List</button>
  </div>

  <h2>Sanctioned Strength</h2>
  <table id="sanctionedStrengthTable">
    <tr>
      <th>Rank</th>
      <th>Strength</th>
      <th>Deputation Strength</th>
    </tr>
    <tr><td>Apex</td><td><input type="number" value="1"></td><td><input type="number" value="0"></td></tr>
    <tr><td>HAG</td><td><input type="number" value="6"></td><td><input type="number" value="1"></td></tr>
    <tr><td>SAG</td><td><input type="number" value="46"></td><td><input type="number" value="10"></td></tr>
    <tr><td>JAG</td><td><input type="number" value="164"></td><td><input type="number" value="15"></td></tr>
    <tr><td>STS</td><td><input type="number" value="249"></td><td><input type="number" value="10"></td></tr>
    <tr><td>JTS</td><td><input type="number" value="262"></td><td><input type="number" value="2"></td></tr>
  </table>

  <h2>Promotion Criteria (Years)</h2>
  <table id="promotionCriteriaTable">
    <tr>
      <th>Rank</th>
      <th>Criteria</th>
      <th>Value</th>
      <th>Regular Service From</th>
      <th>Count From</th> <!-- NEW column -->
    </tr>
  </table>

  <h2>Simulation Start Date</h2>
  <input type="date" id="startDate" value="2024-12-01" />

  <div style="margin-top: 20px; text-align: center;">
    <button id="executeBtn">Execute Simulation</button>
  </div>

  <h2>Results</h2>
  <div id="result"></div>

  <!-- Filter controls are OUTSIDE the scroll pane -->
  <div id="resultsFilter" class="controls-row" style="margin: 10px 0;">
    <label for="filterDate">Show serving as on:</label>
    <input type="date" id="filterDate" />
    <button id="applyFilterBtn">Apply</button>
  </div>

  <!-- SINGLE scroll pane for results table -->
  <div id="resultsPane" class="scroll-pane"></div>

  <!-- Optional: JSON download link kept (hidden until used) -->
  <a id="downloadJsonLink" href="#" download="simulation_results.json" style="display:none;">Download JSON</a>

  <!-- NEW: Monthly Analytics Pane -->
  <h2 style="margin-top: 28px;">Monthly Analytics</h2>
  <div class="controls-row" style="margin: 10px 0;">
    <label for="levelSelect">Level:</label>
    <select id="levelSelect" style="max-width: 220px;">
      <option>JTS</option>
      <option selected>STS</option>
      <option>JAG</option>
      <option>SAG</option>
      <option>HAG</option>
      <option>Apex</option>
    </select>
<label for="granularity" style="margin-left:12px;">Frequency:</label>
<select id="granularity">
  <option value="monthly">Monthly</option>
  <option value="yearly" selected>Yearly</option>
</select>

  </div>

  <div class="analytics">
    <div class="card">
      <h3>Bar Graph</h3>
      <canvas id="monthlyChart"></canvas>
    </div>
    <div class="card">
      <h3>Eligible Officers by Month</h3>
      <div id="eligibleList" class="eligible-list"></div>
    </div>
  </div>
</div>

<script>
// ---------- Utilities ----------
function formatDateDDMMYYYY(dateStr) {
  if (!dateStr) return "";
  const date = new Date(dateStr);
  if (isNaN(date)) return "";
  const dd = String(date.getDate()).padStart(2, '0');
  const mm = String(date.getMonth() + 1).padStart(2, '0');
  const yyyy = date.getFullYear();
  return `${dd}-${mm}-${yyyy}`;
}
function parseDate(v) { if (!v) return null; const d = new Date(v); return isNaN(d) ? null : d; }
function addDays(d, n) { const dd = new Date(d); dd.setDate(dd.getDate() + n); return dd; }
function addMonths(d, n) { const dd = new Date(d); dd.setMonth(dd.getMonth() + n); return dd; }
function yearsBetween(from, to) { if (!from || !to) return 0; return (to - from) / (365 * 24 * 60 * 60 * 1000); }
function monthKey(d) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; }

// NEW: anchoring helper for "Count From" selection
function anchorize(dateObj, mode) {
  if (!dateObj) return null;
  const d = new Date(dateObj);
  if (isNaN(d)) return null;
  switch (mode) {
    case 'jan1_same_year': return new Date(d.getFullYear(), 0, 1);
    case 'jan1_next_year': return new Date(d.getFullYear() + 1, 0, 1);
    case 'same_date':
    default: return d;
  }
}

// ---------- Data Loading & Table Rendering ----------
let OFFICERS = []; // in-memory officers list

function loadOfficerList() {
  fetch('officers_list_1.json')
    .then(res => res.json())
    .then(data => {
      const today = new Date();
      OFFICERS = data
        .filter(o => {
          const ret = o['RetirementDate'] || o['Date_of_Retirement'];
          if (!ret) return true; return parseDate(ret) >= today;
        })
        .map((o, i) => ({
          originalIndex: i,
          ...o,
          ID: o.ID ?? o.Id ?? o.id,
          CurrentRank: o['Current Rank'] ?? o['Current_Rank'] ?? o['Rank'] ?? o['currentRank'],
          DOJ: o['Date_of_Joining'] ?? o['DOJ'],
          P_STS: o['Promotion_Date_to_STS'] ?? o['PromotionDateToSTS'],
          P_JAG: o['Promotion_Date_to_JAG'] ?? o['PromotionDateToJAG'],
          P_SAG: o['Promotion_Date_to_SAG'] ?? o['PromotionDateToSAG'],
          P_HAG: o['Promotion_Date_to_HAG'] ?? o['PromotionDateToHAG'],
          P_Apex: o['Promotion_Date_to_Apex'] ?? o['PromotionDateToApex'],
          Retirement: o['RetirementDate'] ?? o['Date_of_Retirement']
        }));

      // Render table
      const table = document.getElementById('officerListTable');
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      tbody.innerHTML = '';

      if (OFFICERS.length > 0) {
        const cols = Object.keys(OFFICERS[0]);
        thead.innerHTML = '<tr>' + cols.map(k => `<th>${k}</th>`).join('') + '</tr>';
        OFFICERS.forEach(row => {
          const tr = document.createElement('tr');
          cols.forEach(key => {
            const td = document.createElement('td');
            const val = row[key];
            td.textContent = String(key).toLowerCase().includes('date') || /^(DOJ|P_|Retirement)$/.test(key)
              ? formatDateDDMMYYYY(val)
              : (val ?? '');
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
      }
    })
    .catch(err => console.error('Error loading officer list:', err));
}

// ---------- Promotion Criteria UI ----------
const RANKS = ["STS","JAG","SAG","HAG","Apex"]; // promotion targets in ascending order
const ALL_LEVELS = ["JTS","STS","JAG","SAG","HAG","Apex"]; // for analytics selection
const FEEDER = { STS:"JTS", JAG:"STS", SAG:"JAG", HAG:"SAG", Apex:"HAG" };

// DEFAULTS extended with anchorMode for each rule
const DEFAULT_CRITERIA = {
  Apex: { rows: [{criteria:"min_years_at_HAG", value:2, serviceFrom:"P_HAG", anchorMode:"same_date"}] },
  HAG:  { rows: [
           {criteria:"min_years_from_JTS", value:25, serviceFrom:"DOJ",  anchorMode:"same_date"},
           {criteria:"min_years_at_SAG",  value:1,  serviceFrom:"P_SAG", anchorMode:"same_date"},
           {criteria:"or_min_years_at_SAG", value:3, serviceFrom:"P_SAG", anchorMode:"same_date"},
         ]},
  SAG:  { rows: [
           {criteria:"min_years_from_JTS", value:17, serviceFrom:"DOJ",  anchorMode:"same_date"},
           {criteria:"min_years_at_JAG",  value:1,  serviceFrom:"P_JAG", anchorMode:"same_date"},
           {criteria:"or_min_years_at_JAG", value:3, serviceFrom:"P_JAG", anchorMode:"same_date"},
         ]},
  JAG:  { rows: [
           {criteria:"min_years_from_JTS", value:13, serviceFrom:"DOJ",  anchorMode:"same_date"},
           {criteria:"min_years_at_STS",  value:4,  serviceFrom:"P_STS", anchorMode:"same_date"},
           {criteria:"or_min_years_at_STS", value:9, serviceFrom:"P_STS", anchorMode:"same_date"},
         ]},
  STS:  { rows: [{criteria:"min_years_at_JTS", value:4, serviceFrom:"DOJ", anchorMode:"same_date"}] }
};

function buildPromotionCriteriaTable() {
  const table = document.getElementById('promotionCriteriaTable');
  const existingRows = table.querySelectorAll('tr').length;
  if (existingRows > 1) return; // already built

  const addRow = (rank, criteriaName, value, serviceFrom, anchorMode="same_date") => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${rank}</td>
      <td>${criteriaName}</td>
      <td><input type="number" step="0.01" value="${value}"></td>
      <td>
        <select class="service-from">
          <option value="DOJ"${serviceFrom==="DOJ"?" selected":""}>From DOJ (JTS regular service)</option>
          <option value="P_STS"${serviceFrom==="P_STS"?" selected":""}>From STS date</option>
          <option value="P_JAG"${serviceFrom==="P_JAG"?" selected":""}>From JAG date</option>
          <option value="P_SAG"${serviceFrom==="P_SAG"?" selected":""}>From SAG date</option>
          <option value="P_HAG"${serviceFrom==="P_HAG"?" selected":""}>From HAG date</option>
        </select>
      </td>
      <td>
        <select class="anchor-mode">
          <option value="same_date"${anchorMode==="same_date"?" selected":""}>From same date</option>
          <option value="jan1_same_year"${anchorMode==="jan1_same_year"?" selected":""}>From 1 Jan (same year)</option>
          <option value="jan1_next_year"${anchorMode==="jan1_next_year"?" selected":""}>From 1 Jan (following year)</option>
        </select>
      </td>
    `;
    table.appendChild(tr);
  };

  ["STS","JAG","SAG","HAG","Apex"].forEach(rank => {
    DEFAULT_CRITERIA[rank].rows.forEach(r => addRow(rank, r.criteria, r.value, r.serviceFrom, r.anchorMode || "same_date"));
  });
}

// ---------- Reading inputs ----------
function readSanctionedStrength() {
  const capacity = {};
  document.querySelectorAll('#sanctionedStrengthTable tr').forEach((row, i) => {
    if (i === 0) return;
    const rank = row.cells[0].innerText.trim();
    const sanctioned = parseInt(row.cells[1].querySelector('input').value || '0', 10);
    const deputation = parseInt(row.cells[2].querySelector('input').value || '0', 10);
    capacity[rank] = sanctioned + deputation;
  });
  return capacity;
}

function readPromotionCriteria() {
  const criteria = {};
  document.querySelectorAll('#promotionCriteriaTable tr').forEach((row, i) => {
    if (i === 0) return;
    const rank = row.cells[0].innerText.trim();
    const criteriaName = row.cells[1].innerText.trim();
    const value = parseFloat(row.cells[2].querySelector('input').value);
    const serviceFrom = row.cells[3].querySelector('select.service-from').value; // DOJ, P_STS, P_JAG, P_SAG, P_HAG
    const anchorMode = row.cells[4].querySelector('select.anchor-mode').value;   // same_date, jan1_same_year, jan1_next_year
    if (!criteria[rank]) criteria[rank] = {};
    criteria[rank][criteriaName] = { value, serviceFrom, anchorMode };
  });
  return criteria;
}

function getDateFor(off, token) {
  switch (token) {
    case "DOJ":  return parseDate(off.DOJ);
    case "P_STS":return parseDate(off.P_STS);
    case "P_JAG":return parseDate(off.P_JAG);
    case "P_SAG":return parseDate(off.P_SAG);
    case "P_HAG":return parseDate(off.P_HAG);
    default:     return null;
  }
}

function eligible(off, targetRank, now, crit) {
  const feeder = FEEDER[targetRank];
  if (!feeder) return false;
  if ((off.CurrentRank || "").toUpperCase() !== feeder.toUpperCase()) return false;

  const C = crit[targetRank] || {};
  const need = (name) => C[name] ? C[name].value : null;
  const from = (name, fallbackToken) => {
    const rule = C[name];
    const token = (rule && rule.serviceFrom) || fallbackToken;
    const raw = getDateFor(off, token);
    const mode = (rule && rule.anchorMode) || "same_date";
    return anchorize(raw, mode);
  };

  if (targetRank === "STS") {
    const yrs = yearsBetween(from("min_years_at_JTS", "DOJ"), now);
    return yrs >= (need("min_years_at_JTS") ?? Infinity);
  }
  if (targetRank === "JAG") {
    const yrsFromJTS = yearsBetween(from("min_years_from_JTS", "DOJ"), now);
    const yrsAtSTS   = yearsBetween(from("min_years_at_STS", "P_STS"), now);
    const laneA = yrsFromJTS >= (need("min_years_from_JTS") ?? Infinity) &&
                  yrsAtSTS   >= (need("min_years_at_STS") ?? Infinity);
    const laneB = yrsAtSTS   >= (need("or_min_years_at_STS") ?? Infinity);
    return laneA || laneB;
  }
  if (targetRank === "SAG") {
    const yrsFromJTS = yearsBetween(from("min_years_from_JTS", "DOJ"), now);
    const yrsAtJAG   = yearsBetween(from("min_years_at_JAG", "P_JAG"), now);
    const laneA = yrsFromJTS >= (need("min_years_from_JTS") ?? Infinity) &&
                  yrsAtJAG   >= (need("min_years_at_JAG") ?? Infinity);
    const laneB = yrsAtJAG   >= (need("or_min_years_at_JAG") ?? Infinity);
    return laneA || laneB;
  }
  if (targetRank === "HAG") {
    const yrsFromJTS = yearsBetween(from("min_years_from_JTS", "DOJ"), now);
    const yrsAtSAG   = yearsBetween(from("min_years_at_SAG", "P_SAG"), now);
    const laneA = yrsFromJTS >= (need("min_years_from_JTS") ?? Infinity) &&
                  yrsAtSAG   >= (need("min_years_at_SAG") ?? Infinity);
    const laneB = yrsAtSAG   >= (need("or_min_years_at_SAG") ?? Infinity);
    return laneA || laneB;
  }
  if (targetRank === "Apex") {
    const yrsAtHAG = yearsBetween(from("min_years_at_HAG", "P_HAG"), now);
    return yrsAtHAG >= (need("min_years_at_HAG") ?? Infinity);
  }
  return false;
}

// ---------- Simulation + Monthly Analytics ----------
let monthlyStats = {}; // { 'YYYY-MM': { Level: { eligible:[{ID,Name}], vacanciesCreated:n, promotionsMade:n } } }

function ensureMonthLevel(mKey, level) {
  if (!monthlyStats[mKey]) monthlyStats[mKey] = {};
  if (!monthlyStats[mKey][level]) monthlyStats[mKey][level] = { eligible: [], vacanciesCreated: 0, promotionsMade: 0 };
}

function executeSimulation() {
  if (!OFFICERS.length) {
    document.getElementById('result').innerHTML = `<pre>No officers loaded.</pre>`;
    return;
  }

  // Reset analytics & shared state for a fresh run
  monthlyStats = {};
  window.monthlyStats = monthlyStats;
  window.resultData = null;
  window.originalDatesMap = null;

  const capacity = readSanctionedStrength();
  const criteria = readPromotionCriteria();
  const startDate = parseDate(document.getElementById('startDate').value);

  // Deep-copy officers so promotions don't stack across runs
  const officers = OFFICERS.map((o, i) => ({ originalIndex: i, ...JSON.parse(JSON.stringify(o)) }));

  // Determine the last retirement date to bound the loop
  const lastRet = officers.reduce((mx, o) => {
    const r = parseDate(o.Retirement);
    return (!mx || (r && r > mx)) ? r : mx;
  }, null) || startDate;

  const ranksAll = ["JTS","STS","JAG","SAG","HAG","Apex"];
  const incumbents = Object.fromEntries(ranksAll.map(r => [r, 0]));
  officers.forEach(o => { const rk = (o.CurrentRank || o['Current Rank'] || '').trim(); if (incumbents[rk] !== undefined) incumbents[rk]++; });
  const vacancies = Object.fromEntries(ranksAll.map(r => [r, Math.max(0, (capacity[r] ?? 0) - (incumbents[r] ?? 0))]));

  function promote(off, targetRank, when, mKey) {
    const feeder = FEEDER[targetRank]; if (!feeder) return;
    const keyMap = { STS:'P_STS', JAG:'P_JAG', SAG:'P_SAG', HAG:'P_HAG', Apex:'P_Apex' };
    off[keyMap[targetRank]] = when.toISOString();
    off.CurrentRank = targetRank;
    vacancies[targetRank] = Math.max(0, (vacancies[targetRank] ?? 0) - 1);
    vacancies[feeder] = (vacancies[feeder] ?? 0) + 1;
    ensureMonthLevel(mKey, feeder);
    monthlyStats[mKey][feeder].vacanciesCreated += 1;
    ensureMonthLevel(mKey, targetRank);
    monthlyStats[mKey][targetRank].promotionsMade += 1;
  }

  // Run simulation month-by-month
  let now = new Date(startDate);
  while (now <= lastRet) {
    const windowEnd = addMonths(now, 1);
    const mKey = monthKey(now);

    // 1) Eligible lists for each target rank at the start of the month
    ["Apex","HAG","SAG","JAG","STS"].forEach(targetRank => {
      const feeder = FEEDER[targetRank];
      const candidates = officers
        .filter(off => !off._retired)
        .filter(off => (off.CurrentRank || '').toUpperCase() === feeder.toUpperCase())
        .filter(off => eligible(off, targetRank, now, criteria))
        .sort((a,b) => a.originalIndex - b.originalIndex);

      ensureMonthLevel(mKey, targetRank);
      monthlyStats[mKey][targetRank].eligible = candidates.map(c => ({ ID: c.ID, Name: c.Name ?? c['Name'] ?? c.ID }));
    });

    // 2) Retirements in the month → vacancy created at that rank
    officers.forEach(off => {
      const ret = parseDate(off.Retirement);
      if (ret && ret >= now && ret < windowEnd) {
        const r = (off.CurrentRank || '').trim();
        if (vacancies[r] !== undefined) vacancies[r] += 1;
        off._retired = true;
        ensureMonthLevel(mKey, r);
        monthlyStats[mKey][r].vacanciesCreated += 1;
      }
    });

    // 3) Promotions top-down in the month
    ["Apex","HAG","SAG","JAG","STS"].forEach(targetRank => {
      if ((vacancies[targetRank] ?? 0) <= 0) return;
      const feeder = FEEDER[targetRank];
      const candidates = officers
        .filter(off => !off._retired)
        .filter(off => (off.CurrentRank || '').toUpperCase() === feeder.toUpperCase())
        .filter(off => eligible(off, targetRank, now, criteria))
        .sort((a, b) => a.originalIndex - b.originalIndex);

      let slots = vacancies[targetRank];
      for (let i = 0; i < candidates.length && slots > 0; i++) {
        const PROMOTION_DAY_OFFSET = 0; // 0 = 1st day, 1 = 2nd day, etc.
        const promotionDate = addDays(now, PROMOTION_DAY_OFFSET);
        promote(candidates[i], targetRank, promotionDate, mKey);

        slots--;
      }
    });

    now = windowEnd;
  }

  // Store original promotion dates for forecast highlighting
  const originalDates = {};
  OFFICERS.forEach(o => {
    originalDates[o.ID] = {
      P_STS: o.P_STS ?? o['Promotion_Date_to_STS'] ?? null,
      P_JAG: o.P_JAG ?? o['Promotion_Date_to_JAG'] ?? null,
      P_SAG: o.P_SAG ?? o['Promotion_Date_to_SAG'] ?? null,
      P_HAG: o.P_HAG ?? o['Promotion_Date_to_HAG'] ?? null,
      P_Apex: o.P_Apex ?? o['Promotion_Date_to_Apex'] ?? null
    };
  });

  const result = {
    startedOn: startDate.toISOString(),
    capacityPerRank: capacity,
    finalVacancies: vacancies,
    officers: officers.map((o, i) => ({
      originalIndex: i,
      ID: o.ID,
      Name: o.Name ?? o['Name'],
      CurrentRank: o.CurrentRank,
      DOJ: o.DOJ,
      Promotion_Date_to_STS: o.P_STS ?? null,
      Promotion_Date_to_JAG: o.P_JAG ?? null,
      Promotion_Date_to_SAG: o.P_SAG ?? null,
      Promotion_Date_to_HAG: o.P_HAG ?? null,
      Promotion_Date_to_Apex: o.P_Apex ?? null,
      RetirementDate: o.Retirement
    }))
  };

  window.resultData = result;
  window.originalDatesMap = originalDates;
  window.monthlyStats = monthlyStats;

  document.getElementById('result').innerHTML =
    `<pre>Capacity (sanctioned + deputation): ${JSON.stringify(capacity, null, 2)}\nFinal Vacancies: ${JSON.stringify(vacancies, null, 2)}</pre>`;

  const filterInput = document.getElementById('filterDate');
  if (!filterInput.value) filterInput.value = startDate.toISOString().split('T')[0];
  recalcRanksAndDisplay(filterInput.value);

  // Initialize the analytics
  const level = document.getElementById('levelSelect').value;
  renderAnalytics(level);
}

function recalcRanksAndDisplay(selectedDate) {
  const filterDate = parseDate(selectedDate);
  const result = window.resultData; const originalDates = window.originalDatesMap;
  if (!result) return;

  let filtered = result.officers.filter(o => { const ret = parseDate(o.RetirementDate); return !ret || ret >= filterDate; });

  const caps = {
    Apex: result.capacityPerRank["Apex"] || 0,
    HAG: result.capacityPerRank["HAG"] || 0,
    SAG: result.capacityPerRank["SAG"] || 0,
    JAG: result.capacityPerRank["JAG"] || 0,
    STS: result.capacityPerRank["STS"] || 0
  };

  let counters = { Apex: 0, HAG: 0, SAG: 0, JAG: 0, STS: 0 };
  filtered.forEach(o => {
    if (counters.Apex < caps.Apex) { o.CurrentRank = "Apex"; counters.Apex++; }
    else if (counters.HAG < caps.HAG) { o.CurrentRank = "HAG"; counters.HAG++; }
    else if (counters.SAG < caps.SAG) { o.CurrentRank = "SAG"; counters.SAG++; }
    else if (counters.JAG < caps.JAG) { o.CurrentRank = "JAG"; counters.JAG++; }
    else if (counters.STS < caps.STS) { o.CurrentRank = "STS"; counters.STS++; }
    else { o.CurrentRank = "JTS"; }
  });

  let serialMap = {}; let serialCounter = 1;
  function assignSerialsForRank(rank) { filtered.forEach(o => { if (o.CurrentRank === rank && serialMap[o.ID] == null) serialMap[o.ID] = serialCounter++; }); }
  ["Apex","HAG","SAG","JAG","STS","JTS"].forEach(assignSerialsForRank);

  const resultsPane = document.getElementById('resultsPane');
  resultsPane.innerHTML = '';
  const table = document.createElement('table'); table.style.width = '100%'; table.style.borderCollapse = 'collapse';
  const cols = ["Serial", ...Object.keys(filtered[0] || {})];
  const thead = document.createElement('thead'); thead.innerHTML = '<tr>' + cols.map(k => `<th>${k}</th>`).join('') + '</tr>';
  table.appendChild(thead);
  const tbody = document.createElement('tbody');

  filtered.forEach(row => {
    const tr = document.createElement('tr');
    cols.forEach(key => {
      const td = document.createElement('td');
      if (key === "Serial") { td.textContent = serialMap[row.ID] || ''; }
      else {
        const val = row[key];
        const isDateField = String(key).toLowerCase().includes('date');
        if (key.startsWith('Promotion_Date_to_')) {
          const mapKey = { Promotion_Date_to_STS: 'P_STS', Promotion_Date_to_JAG: 'P_JAG', Promotion_Date_to_SAG: 'P_SAG', Promotion_Date_to_HAG: 'P_HAG', Promotion_Date_to_Apex: 'P_Apex' }[key];
          const originallyBlank = originalDates[row.ID] && !originalDates[row.ID][mapKey];
          if (originallyBlank && val) { td.style.color = 'blue'; td.style.fontWeight = 'bold'; }
        }
        td.textContent = isDateField ? formatDateDDMMYYYY(val) : (val ?? '');
      }
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody); resultsPane.appendChild(table);
}

// ---------- Analytics UI ----------
// ---------- Pretty Month Label ----------
function prettyMonthLabel(mKey) {
  // mKey is "YYYY-MM"
  const [y, m] = mKey.split('-').map(Number);
  const d = new Date(y, m - 1, 1);
  return d.toLocaleString(undefined, { month: 'short' }) + " ’" + String(y).slice(-2);
}

// ---------- Improved Analytics Chart ----------
let chartRef = null;

function renderAnalytics(level) {
  const stats = window.monthlyStats || {};
  const months = Object.keys(stats).sort();
  const labels = months.map(prettyMonthLabel);

  const vacancies = months.map(m => (stats[m][level]?.vacanciesCreated) || 0);
  const promotions = months.map(m => (stats[m][level]?.promotionsMade) || 0);
  const eligibleCount = months.map(m => (stats[m][level]?.eligible?.length) || 0);

  // Separate caps for left (bars) and right (line) axes for readability
  const leftMax  = Math.max(0, ...vacancies, ...promotions);
  const rightMax = Math.max(0, ...eligibleCount);

  const canvas = document.getElementById('monthlyChart');
  if (chartRef) { chartRef.destroy(); chartRef = null; }

  chartRef = new Chart(canvas, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'Vacancies Created',
          data: vacancies,
          borderRadius: 6,
          maxBarThickness: 28,
          categoryPercentage: 0.72,
          barPercentage: 0.9,
          yAxisID: 'yBars'
        },
        {
          label: 'Promotions Made',
          data: promotions,
          borderRadius: 6,
          maxBarThickness: 28,
          categoryPercentage: 0.72,
          barPercentage: 0.9,
          yAxisID: 'yBars'
        },
        {
          type: 'line',
          label: 'Eligible Officers',
          data: eligibleCount,
          yAxisID: 'yLine',
          tension: 0.35,
          pointRadius: 3,
          pointHoverRadius: 5,
          fill: false
        }
      ]
    },
    options: {
      // keep non-responsive; height is fixed via CSS we added earlier
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      animation: { duration: 600, easing: 'easeOutQuart' },
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 14 } },
        tooltip: {
          backgroundColor: 'rgba(0,0,0,0.85)',
          padding: 10,
          displayColors: true,
          callbacks: {
            title: (items) => items[0].label, // already pretty month
            footer: (items) => {
              const vac = items.find(i => i.dataset.label === 'Vacancies Created')?.raw ?? 0;
              const pro = items.find(i => i.dataset.label === 'Promotions Made')?.raw ?? 0;
              const net = vac - pro;
              return `Net vacancies: ${net}`;
            },
            afterLabel: (ctx) => {
              if (ctx.dataset.label !== 'Eligible Officers') return '';
              const monthKey = months[ctx.dataIndex];
              const names = (stats[monthKey][level]?.eligible || []).map(o => o.Name || o.ID);
              const shown = names.slice(0, 5);
              const more = names.length > 5 ? ` (+${names.length - 5} more)` : '';
              return shown.length ? `\n${shown.join(', ')}${more}` : '';
            }
          }
        }
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: { maxRotation: 0, autoSkipPadding: 16 }
        },
        yBars: {
          beginAtZero: true,
          suggestedMax: (Number.isFinite(leftMax) ? leftMax : 0) + 2,
          grid: { color: 'rgba(0,0,0,0.06)' },
          ticks: { precision: 0 },
          title: { display: true, text: 'Vacancies / Promotions' }
        },
        yLine: {
          position: 'right',
          beginAtZero: true,
          suggestedMax: (Number.isFinite(rightMax) ? rightMax : 0) + 2,
          grid: { drawOnChartArea: false }, // keep the grid clean
          ticks: { precision: 0 },
          title: { display: true, text: 'Eligible' }
        }
      }
    }
  });

  // Right-side list remains the same
  const el = document.getElementById('eligibleList');
  el.innerHTML = '';
  months.forEach(m => {
    const names = (stats[m][level]?.eligible || []).map(o => o.Name || o.ID);
    const row = document.createElement('div');
    row.className = 'month-row';
    row.innerHTML = `<strong>${prettyMonthLabel(m)}</strong> <span class="tag">${names.length} eligible</span><div style="font-size: 13px; margin-top: 4px;">${names.length ? names.join(', ') : '<em>None</em>'}</div>`;
    el.appendChild(row);
  });
}

// ---------- Init ----------
 document.addEventListener('DOMContentLoaded', () => {
  loadOfficerList();
  buildPromotionCriteriaTable();
  document.getElementById('executeBtn').addEventListener('click', executeSimulation);
  document.getElementById('refreshBtn').addEventListener('click', loadOfficerList);

  document.getElementById('applyFilterBtn').addEventListener('click', () => {
    const v = document.getElementById('filterDate').value; recalcRanksAndDisplay(v);
  });
  document.getElementById('filterDate').addEventListener('change', (e) => { recalcRanksAndDisplay(e.target.value); });

  document.getElementById('levelSelect').addEventListener('change', (e) => { renderAnalytics(e.target.value); });
});
</script>

<script>
// ===== Injected by ChatGPT: Monthly ⇄ Yearly toggle support =====
(function() {
  function getGranularity() {
    const sel = document.getElementById('granularity');
    return sel ? sel.value : 'yearly';
  }
  // Keep one global chart instance (shadow existing if any)
  window.chartRef = window.chartRef || null;

  // New unified renderer; overrides previous renderAnalytics if defined earlier
  window.renderAnalytics = function(level, mode) {
    try {
      const stats = window.monthlyStats || {};
      const monthKeys = Object.keys(stats).sort(); // 'YYYY-MM'
      const currentMode = mode || getGranularity();

      // ---- Aggregators ----
      const byMonth = () => {
        const labels = monthKeys;
        const vacancies = [];
        const promotions = [];
        const eligibleAvg = [];
        const eligibleNamesByLabel = new Map();

        monthKeys.forEach(m => {
          const s = stats[m]?.[level];
          const vac = s?.vacanciesCreated || 0;
          const pro = s?.promotionsMade || 0;
          const names = (s?.eligible || []).map(o => o.Name || o.ID);
          vacancies.push(vac);
          promotions.push(pro);
          eligibleAvg.push(names.length);
          eligibleNamesByLabel.set(m, new Set(names));
        });

        return { labels, vacancies, promotions, eligibleAvg, eligibleNamesByLabel, xTitle: 'Month', vacTitle: 'Vacancies / Promotions (totals)', eligTitle: 'Eligible (count)' };
      };

      const byYear = () => {
        const yearKeys = [...new Set(monthKeys.map(m => m.slice(0,4)))].sort();
        const agg = {};
        yearKeys.forEach(y => (agg[y] = { vac:0, pro:0, eligCounts:[], eligNames:new Set() }));

        monthKeys.forEach(m => {
          const y = m.slice(0,4);
          const s = stats[m]?.[level];
          if (!s) return;
          agg[y].vac += s.vacanciesCreated || 0;
          agg[y].pro += s.promotionsMade || 0;
          const names = (s.eligible || []).map(o => o.Name || o.ID);
          agg[y].eligCounts.push(names.length);
          names.forEach(n => agg[y].eligNames.add(n));
        });

        const labels = yearKeys;
        const vacancies = yearKeys.map(y => agg[y].vac);
        const promotions = yearKeys.map(y => agg[y].pro);
        const eligibleAvg = yearKeys.map(y => {
          const arr = agg[y].eligCounts;
          return arr.length ? Math.round(arr.reduce((a,b)=>a+b,0)/arr.length) : 0;
        });

        const eligibleNamesByLabel = new Map(yearKeys.map(y => [y, agg[y].eligNames]));
        return { labels, vacancies, promotions, eligibleAvg, eligibleNamesByLabel, xTitle: 'Year', vacTitle: 'Vacancies / Promotions (totals)', eligTitle: 'Eligible (yearly avg)' };
      };

      const data = (currentMode === 'monthly') ? byMonth() : byYear();

      // ---- Chart ----
      const canvas = document.getElementById('monthlyChart');
      if (!canvas || typeof Chart === 'undefined') return;

      if (window.chartRef) { try { window.chartRef.destroy(); } catch(e) {} window.chartRef = null; }

      const leftMax  = Math.max(0, ...data.vacancies, ...data.promotions);
      const rightMax = Math.max(0, ...data.eligibleAvg);

      window.chartRef = new Chart(canvas, {
        type: 'bar',
        data: {
          labels: data.labels,
          datasets: [
            { label: 'Vacancies Created', data: data.vacancies, borderRadius: 6, maxBarThickness: 28, categoryPercentage: 0.72, barPercentage: 0.9, yAxisID: 'yBars' },
            { label: 'Promotions Made',  data: data.promotions, borderRadius: 6, maxBarThickness: 28, categoryPercentage: 0.72, barPercentage: 0.9, yAxisID: 'yBars' },
            { type: 'line', label: (currentMode === 'monthly') ? 'Eligible (count)' : 'Eligible (yearly avg)', data: data.eligibleAvg, yAxisID: 'yLine', tension: 0.35, pointRadius: 3, pointHoverRadius: 5, fill: false }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { position: 'bottom', labels: { usePointStyle: true, padding: 14 } },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.85)',
              padding: 10,
              displayColors: true,
              callbacks: {
                title: items => `${(currentMode === 'monthly') ? 'Month' : 'Year'} ${items[0].label}`,
                footer: items => {
                  const vac = items.find(i => i.dataset.label.includes('Vacancies'))?.raw ?? 0;
                  const pro = items.find(i => i.dataset.label.includes('Promotions'))?.raw ?? 0;
                  return `Net vacancies: ${vac - pro}`;
                }
              }
            }
          },
          scales: {
            x: { grid: { display: false }, ticks: { maxRotation: 0, autoSkipPadding: 16 }, title: { display: true, text: data.xTitle } },
            yBars: {
              beginAtZero: true,
              suggestedMax: (Number.isFinite(leftMax) ? leftMax : 0) + 2,
              grid: { color: 'rgba(0,0,0,0.06)' },
              ticks: { precision: 0 },
              title: { display: true, text: data.vacTitle }
            },
            yLine: {
              position: 'right',
              beginAtZero: true,
              suggestedMax: (Number.isFinite(rightMax) ? rightMax : 0) + 2,
              grid: { drawOnChartArea: false },
              ticks: { precision: 0 },
              title: { display: true, text: data.eligTitle }
            }
          }
        }
      });

      // ---- Right-hand eligible list ----
      const el = document.getElementById('eligibleList');
      if (el) {
        el.innerHTML = '';
        data.labels.forEach(lbl => {
          const namesSet = data.eligibleNamesByLabel.get(lbl) || new Set();
          const names = Array.from(namesSet);
          const shown = names.slice(0, 20);
          const more  = names.length > 20 ? ` (+${names.length - 20} more)` : '';
          const row = document.createElement('div');
          row.className = 'month-row';
          row.innerHTML = `<strong>${lbl}</strong> <span class="tag">${(currentMode === 'monthly') ? names.length + ' eligible' : names.length + ' unique eligible'}</span><div style="font-size:13px;margin-top:4px;">${shown.length ? shown.join(', ') + more : '<em>None</em>'}</div>`;
          el.appendChild(row);
        });
      }
    } catch (e) {
      console.error('renderAnalytics override error:', e);
    }
  };

  // Hook granularity changes
  document.addEventListener('DOMContentLoaded', function() {
    const granSel = document.getElementById('granularity');
    const levelSel = document.getElementById('levelSelect');
    if (granSel) {
      granSel.addEventListener('change', () => {
        const level = (levelSel && levelSel.value) ? levelSel.value : 'Level-1';
        window.renderAnalytics(level);
      });
    }
    // Try an initial repaint after a small delay to allow data to be loaded
    setTimeout(() => {
      const level = (levelSel && levelSel.value) ? levelSel.value : 'Level-1';
      try { window.renderAnalytics(level); } catch(e) {}
    }, 100);
  });
})();
// ===== End injected block =====
</script>
</body>
</html>
